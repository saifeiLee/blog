---
title: 隐式类型转换
---

#### 强/弱类型

编程语言有强类型和弱类型之分。强类型语言在编译时有更严格的类型限制规则，这些规则影响着变量赋值，返回值和函数调用。另一方面,弱类型的编程语言有着更为松散的类型规则,往往在运行时执行隐式类型转换，从而产生意料之外的结果。

** ECMAScript的加法特殊行为 **

- 某个运算数是NaN, 那么结果为NaN.
- -Infinity加-Infinity ,结果为-Infinity
- Infinity加-Infinity,结果为NaN.
- +0 加+0, 结果为+0.
- -0加+0,结果为+0
- -0加-0,结果为-0

不过，如果某个运算数是字符串，那么采用下列规则：
- 如果两个运算数都是字符串,把第二个字符串连接到第一个上。
- 如果只有一个运算数是字符串,把另一个运算数转换成字符串,结果是两个字符串连接成的字符串

** 减号运算符 **

- +0 减 +0,结果为+0
- -0 减 -0,结果为-0
- +0 减 -0,结果为+0
- 某个运算符不是数字,则结果为NaN

1. JS中只有三种类型转换:
- to string
- to boolean
- to number

2. 对基本类型和对象的转化逻辑不一样,但都只以上述三种方式。

### String conversion

```javascript
String(123) // explicit
123 + ''    // implicit
```

注意:Symbol 只能显式转换。
```javascript
String(Symbol('my symbol'))   // 'Symbol(my symbol)'
'' + Symbol('my symbol')      // TypeError is thrown
```

```javascript
Number("\n")                   // 0
Number(null)                   // 0
Number(undefined)              // NaN
```

在把string转换成number的过程中,JS引擎首先trim()字符串。

2个规则：
1. When applying == to null or undefined, numeric conversion does not happen. null equals only to null or undefined, and does not equal to anything else.
2. NaN does not equal to anything even itself。

Objects are converted to primitives via the internal [[ToPrimitive]] method, which is responsible for both numeric and string conversion.

```javascript
['x'] == 'x'  
==> 'x' == 'x'
==>  true
```

`+` operator triggers numeric conversion for []. Array’s valueOf() method is ignored, because it returns array itself, which is non-primitive. Array’s toString returns an empty string.

```javascript
[] + null + 1  
==>  '' + null + 1  
==>  'null' + 1  
==> 'null1'
```