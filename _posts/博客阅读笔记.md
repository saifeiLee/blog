# JavaScript深入之从原型到原型链

- `prototype` 是函数才有的属性
- 每个JS对象都有一个`__proto__`属性，这个属性会指向该对象的原型。
- 每个原型都有一个 constructor 属性指向关联的构造函数

# 词法作用域和动态作用域

- JS采用的是词法作用域，即静态作用域.函数的作用域基于函数创建的位置。
- JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。

# 执行上下文栈(execution context stack)

- 可执行代码：全局代码、函数代码、eval代码
- 执行上下文(execution context)定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行上下文都有一个对应的变量对象(variable object)
- 当JavaScript遇到一段可执行代码是会创建对应的execution context.
- 每个执行上下文，都有三个重要属性：变量对象、作用域链、this
- 在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

```javascript
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
// output: [Function: foo]
```

### for..of

只对可遍历的对象有用,可遍历的对象必须有`@@iterator`属性(或者来自原型链),可用`Symbol.iterator`为key去判断

```javascript
const str = new String('Chidume');
log(typeof str[Symbol.iterator]);
```

## 2019-01-04

### session存储

- 用cookie存储
- URL重写
- 隐藏表单字段

### session安全

- cookie比URL安全，所以用cookie传递session
- 会话传递机制导致的劫持问题,要保护cookie(使用HttpOnly/https)
- 设置cookie和session的过期时间保持一致
- 会话固定（解决：将浏览器的UA头保存到session中）
- 定期重置sessionID.
- 正确关闭会话.(1.删除传递sessionID的cookie;2.删除session文件;3.删除session全局变变量)

## 2019-01-05

### var/不加var

不加var等于为全局对象添加了一个可配置属性,加var等于为全局变量添加了一个不可配置属性。

### 变量提升

```javascript
var x = 1; // Initialize x
console.log(x + " " + y); // '1 undefined'
var y = 2; // Initialize y

// The above example is implicitly understood as this: 
var x; // Declare x
var y; // Declare y
// End of the hoisting.

x = 1; // Initialize x
console.log(x + " " + y); // '1 undefined'
y = 2; // Initialize y
```

- this的指向，是在函数被调用的时候确定的

### session/cookies区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

### HTTP POST/PUT区别

> 都可以用于创建,不同在于动作执行的目标。举例来说,若要设计一个提问题的API,如果对一个question list 执行动作，用POST,如果是对一个具体的问题,用PUT.

一些参考：

1. Do you name your URL objects you create explicitly, or let the server decide? If you name them then use PUT. If you let the server decide then use POST.
2. PUT is idempotent, so if you PUT an object twice, it has no effect. This is a nice property, so I would use PUT when possible.
3. You can update or create a resource with PUT with the same object URL
4. With POST you can have 2 requests coming in at the same time making modifications to a URL, and they may update different parts of the object.

