---
title: 红宝书
---
# 阅读笔记

## 递归

- `arguments.callee`是一个指向正在执行的函数的指针,可用来实现函数的递归调用，比使用函数名更保险，因为函数名作为指向原始函数的指针可能会被修改。

```javascript
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

但是在`strict`模式下,不能通过脚本访问`arguments.callee`,访问这个属性会导致错误.解决方法: 命名函数表达式

```javascript
var factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num - 1);
    }
});
```

以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。

## 执行环境和作用域

- 执行环境定义了变量或函数有权访问的其他数据,每个执行环境都有一个与之关联的`变量对象`,环境中定义的变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象,但解析器在处理数据时会在后台使用它。
- 执行环境分为全局执行环境和函数执行环境。
- 每次进入一个新执行环境,都会创建一个用于搜索变量和函数的作用域链.
- 变量的执行环境有助于确定应该何时释放内存。

- 当执行流进入下列任何一个语句时,作用域链会加长:
    1. try-catch语句的catch块
    2. with语句

- 使用`var`声明的变量会自动添加到最接近的环境中,若省略`var`,该变量会自动被添加到全局环境.
- 垃圾回收机制的原理：找出那些不再使用的变量,释放其占用的内存。常见的两个策略：`标记清除`和`引用计数`.
- 解除引用:当数据不再有用,建议把值设置为`null`.作用是让值脱离执行环境,以便垃圾收集器下次运行时将其回收。
- 确定一个值是那种基本类型用`typeof`操作符,确定是哪种引用类型可以用`instanceof`操作符.
- 基本数据类型:Undefined, Null, Boolean, Number, String, Symbol.

### 闭包

当某个函数第一次被调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即[[Scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。例子:

```javascript
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
var result = compare(5, 10);
```

![scope chain](../assets/images/scope-chain.png)

- 由于闭包会携带包含它的函数的作用域,因此会比其他函数占有更多的内存.
- 闭包会引用包含函数的整个活动对象。

#### 闭包与变量

> 闭包只能取得包含函数中任何变量的最后一个值。
例子：

```javascript
function createFunction() {
    var result = new Array();
    // 注意此处使用`var`
    for (var i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }
    return result;
}
let res = createFunction();
for(let i = 0; i < 10; i++) {
    console.log((res[i])());
}
// 输出: 全为10
```

表面上看,似乎每个函数都应该返回自己的索引值,即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。

```javascript
function createFunction() {
    var result = new Array();

    for (var i = 0; i < 10; i++) {
        result[i] = function(num) {
            return function() {
                return num;
            };
        }(i);
    }

    return result;
}
```

或者使用`let`

```javascript
function createFunction() {
    var result = new Array();
    // 注意此处使用`let`
    for (let i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }
    return result;
}
let res = createFunction();
for(let i = 0; i < 10; i++) {
    console.log((res[i])());
}
// 输出: 1, 2, 3, 4, ... , 8, 9 （索引）
```

#### 内存泄漏

- 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。

### BOM

- 最好用`top`而非`window`来引用框架,因为top对象始终指向最高层的框架,也就是浏览器窗口。因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架。
- 在使用框架的情况下，浏览器中会存在多个Global对象。在每个框架中定义的全局变量会自动成为框架中window对象的属性。由于每个window对象都包含原生类型的构造函数，因此每个框架都有一套自己的构造函数，这些构造函数一一对应，但并不相等。例如，top.Object并不等于top.frames[0].Object。这个问题会影响到对跨框架传递的对象使用instanceof操作符。
- 跨浏览器取得窗口左边和上边的位置:

```javascript
var leftPos = (typeof window.screenLeft == 'number') ? window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == 'number') ? window.screenTop : screenY;
```

- 解析查询字符串:

```javascript
function getQueryStringArgs () {
    var qs = (location.search.length > 0 ? location.search.substring(1) : ""),
    args = {},
    items = qs.length ? qs.split("&") : [],
    item = null,
    name = null,
    value = null,
    len = items.length;

    for (let i = 0; i < len; i++) {
        item = items[i].split("=");
        name = decodeURIComponent(item[0]);
        value = decodeURIComponent(item[1]);

        if (name.length) {
            args[name] = value;
        }
    }
    return args;
}
```

### DOM

#### 节点层次

##### Node类型

- JS所有节点类型都继承自Node类型。
- NodeList是一种类数组对象,它是基于DOM结构`动态`执行查询的结果,其`length`属性表示的是访问NodeList的那一刻,其中包含的节点数量。
- 几个属性:parentNode, childNodes, previousSibling, nextSibling, firstChild, lastChild, `ownerDocument`
- 操作节点：appendChild(), insertBefore(), replaceChild(), removeChild(), cloneNode(), normalize()
- cloneNode()不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序等。这个方法只复制特性、（在明确指定的情况下也复制）子节点,复制前建议先移除事件处理程序。

##### Document类型

- document对象表示整个HTML页面,可作为全局对象访问,子节点可能是一个DocumentType(最多1个)、Element(最多1个)、ProcessingInstruction或Comment。
- 常用属性: URL, domain, referrer
- 当页面中包含来自其他子域的框架或内嵌框架时,通过将每个页面的document.domain设置为相同的值,这些页面就可以互相访问对方包含的JS对象了.
- 查找元素: getElementById(), getElementsByTagName(), getElementByName()
- 特殊集合： document.anchors, document.forms, document.images, document.links
- 取得特性: getAttribute(), setAttribute(), removeAttribute()
- NodeList, NamedNodeMaped和HTMLCollection都是动态的,所有NodeList对象都是在访问DOM文档时实时运行的查询。应尽量减少访问NodeList的次数,因为每次访问NodeList都会运行一次基于文档的查询,所以可以考虑将NodeList中的值缓存起来。
- CDATA指的是不应被XML解析器进行解析的文本数据,只出现在XML文档中。

> toString()和valueOf()的区别:
> toString()将数据对象用字符串表示,特殊的地方在于:表示对象的时候,输出"[object Object]]",表示数组的时候输出数组内容以逗号连接的字符串,相当于Array.split(',')

- 递增、递减运算符对任何值都适用,所遵循的规则：
    1. 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。
    2. ...不包含数字字符的字符串,将变量的值设置为NaN。字符串变量变成数值变量。
    3. 应用于对象时,先调用对象的valueOf()方法,取得一个可供操作的值,再应用上述规则,如果结果是NaN,则在调用toString()方法后再应用前述规则。对象变量变成数值变量。