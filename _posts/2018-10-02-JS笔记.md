---
title: 红宝书笔记
---
# 阅读笔记

## 递归

- `arguments.callee`是一个指向正在执行的函数的指针,可用来实现函数的递归调用，比使用函数名更保险，因为函数名作为指向原始函数的指针可能会被修改。

```javascript
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * arguments.callee(num-1);
    }
}
```

但是在`strict`模式下,不能通过脚本访问`arguments.callee`,访问这个属性会导致错误.解决方法: 命名函数表达式

```javascript
var factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num - 1);
    }
});
```

以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。

## 执行环境和作用域

- 执行环境定义了变量或函数有权访问的其他数据,每个执行环境都有一个与之关联的`变量对象`,环境中定义的变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象,但解析器在处理数据时会在后台使用它。
- 执行环境分为全局执行环境和函数执行环境。
- 每次进入一个新执行环境,都会创建一个用于搜索变量和函数的作用域链.
- 变量的执行环境有助于确定应该何时释放内存。

- 当执行流进入下列任何一个语句时,作用域链会加长:
    1. try-catch语句的catch块
    2. with语句

- 使用`var`声明的变量会自动添加到最接近的环境中,若省略`var`,该变量会自动被添加到全局环境.
- 垃圾回收机制的原理：找出那些不再使用的变量,释放其占用的内存。常见的两个策略：`标记清除`和`引用计数`.
- 解除引用:当数据不再有用,建议把值设置为`null`.作用是让值脱离执行环境,以便垃圾收集器下次运行时将其回收。
- 确定一个值是那种基本类型用`typeof`操作符,确定是哪种引用类型可以用`instanceof`操作符.
- 基本数据类型:Undefined, Null, Boolean, Number, String, Symbol.

### 闭包

当某个函数第一次被调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即[[Scope]]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。例子:

```javascript
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
var result = compare(5, 10);
```

![scope chain](../assets/images/scope-chain.png)

- 由于闭包会携带包含它的函数的作用域,因此会比其他函数占有更多的内存.
- 闭包会引用包含函数的整个活动对象。

#### 闭包与变量

> 闭包只能取得包含函数中任何变量的最后一个值。
例子：

```javascript
function createFunction() {
    var result = new Array();
    // 注意此处使用`var`
    for (var i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }
    return result;
}
let res = createFunction();
for(let i = 0; i < 10; i++) {
    console.log((res[i])());
}
// 输出: 全为10
```

表面上看,似乎每个函数都应该返回自己的索引值,即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。

```javascript
function createFunction() {
    var result = new Array();

    for (var i = 0; i < 10; i++) {
        result[i] = function(num) {
            return function() {
                return num;
            };
        }(i);
    }

    return result;
}
```

或者使用`let`

```javascript
function createFunction() {
    var result = new Array();
    // 注意此处使用`let`
    for (let i = 0; i < 10; i++) {
        result[i] = function() {
            return i;
        };
    }
    return result;
}
let res = createFunction();
for(let i = 0; i < 10; i++) {
    console.log((res[i])());
}
// 输出: 1, 2, 3, 4, ... , 8, 9 （索引）
```

#### 内存泄漏

- 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。