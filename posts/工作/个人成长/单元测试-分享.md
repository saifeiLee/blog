# 单元测试

## 这次分享要达到的目标

1. 了解jest环境配置,常用技巧(mock、snapshot)
2. 怎么做单测(组件snapshot, 逻辑路径，预期行为)
3. 单元测试在项目中的实际例子（hls.js/Draggable/Antd）

## 提纲

- mock input
- test unit的划分
- result check
- unit test的成本、收益、局限性

## 草稿

大家下午好，之前我尝试给我们的项目配置了jest单测环境，在这个过程中有遇到一些问题，今天跟大家分享交流一下，只希望能帮助大家不再为同样的问题所困。单测的框架有很多种，因为我只用了jest,所以我们这次分享就以jest为主。

好的，现在开始。这次分享有三个目标：

1. 了解jest 环境配置
2. 了解常用的单测方法
3. 一些实际的例子

首先,我们可以通过三种方式配置jest:

1. package.json, 设置"jest": {}，
2. jest.config.js配置文件
3. jest --config <path/to/file.js>

这三种方式都是做一件事：让jest拿到配置文件，我们以jest.config.js配置文件为例。jest-CLI本身提供了一个很方便的指令，帮助生成一份默认的配置 `jest --init`，大概长这样。生成的默认配置长这样。jest提供了非常丰富的配置项，例如 transform, 配置文件编译方式，transformIgnorePatterns，跟transform搭配，告诉jest哪些文件不处理。
setupFiles，配置脚本，用于在测试文件运行之前执行，配置测试环境，为测试用例的执行提供支持，例如：我们的项目中依赖了比如我们的项目依赖了canvas，但是node环境不支持canvas,就需要引入'jest-canvas-mock'来支持canvas的API。

配置好了环境，接下来我们就要开始写用例了。单元测试，我的理解是对程序的最小可测试单元进行测试，我们找到一个最小测试单元，我们给他一个输入，然后检验他给出的结果是否符合预期。为了保持单元测试用例的稳定性，单元测试用例的执行结果不应该依赖外部模块。要做到这一点，我们需要一种方式来隔离程序对外部模块的依赖。jest的答案是`mock`。通过mock，我们可以自定义依赖项的实际结果。以我们项目为例：Text组件的单测用例中我们import了三个模块，其中作为测试单元的TextElement本身依赖了大量的外部模块，但实际我们需要的只有enow-kernel模块中的`PureComponent`和`CommonProps`，我们可以通过mock,来告诉测试用例，这两个依赖项的返回是什么，直接拿到我们想要的那个结果。

现在我们拿到了测试单元的运行结果，我们如何检测这个结果是否符合预期？或者进一步来说，我们如何确定这个测试单元的运行过程是符合我们预期的？我们可以从几个角度去入手：

1. 代码的行为
2. 代码的执行结果

例如：

1. 组件的事件回调应该在事件触发时就响应
2. Quill2EN的测试用例中，我明确知道En2Quill的转换结果应该包含哪些字段，可以通过断言去测试。

关于结果可靠性的检验，jest提供了一种方式，snapshot, 对前端组件的测试非常有用。通过`toMatchSnapshot`方法，jest生成一份当前用例运行结果的快照，之后每次执行测试用例都会去检验快照是否发生了变化。我们Text组件的快照大概长这样：
