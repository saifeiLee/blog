# 书写加速

## 提纲

### 1. 方案简介

 enow事件流->electron->Node-Addon->Turn on/off Accelerator

### 遇到的问题

    a: 首笔延迟（视频展示）
    d: 两端线条绘制的一致性

### 3. 问题原因简介

#### 首笔延迟

安卓端启动需要时间，这段时间内的事件点丢失导致首笔绘制的延迟。

#### 两端线条绘制的一致性

[视频展示] 原因分析：点越多，越能绘制出完全契合轨迹的曲线，如果只有两个点（起始点和结束点）画出来的是一个线段，所以可以认为点越少，画出的曲线就会越偏离真实轨迹。
如何拿到更多的点：PointerMove事件

#### PointerEvent简介

- 继承自MouseEvent

#### 为什么二次贝塞尔曲线能够画出圆滑的曲线

## 草稿

各位好，今天的分享主题是书写优化，有两个部分构成：书写加速的方案，和丢点问题的解决方案。

这次的加速方案，其核心是安卓伪加速。整个方案中有几个关键角色：安卓加速应用，职责是在安卓层绘制出书写曲线，然后在收到指令时将其清除。MQTT是我们五代机上已有的一个服务模块，作用是实现双系统之间的通信。最后一个角色是Node模块，负责跟MQTT模块通信，将底层的接口封装暴露给业务层使用。我们在Electron层接入Node模块，将接口进行封装，最终通过
事件通信的方式实现安卓加速的开启和关闭。按照这个方案实现的第一版，效果是这个样子：TODO: 第一版的视频。

还存在一些问题需要解决：

首笔延迟问题，这个问题的原因是安卓应用的启动[start]需要时间，在这段时间内的点被丢掉了。解决的办法有两种：

1. 应用层前置[start]操作。start动作现在是在画笔按下开始绘制时触发，可以考虑前置到工具栏切换到画笔时就触发，这样开始绘制时的点就不会丢。这个方法的问题在于，如果我切换到画笔但是却没操作画布，而是点击其他区域，例如缩略图，安卓层也会画出线。从而我们需要对交互做很多兼容处理。所以这不是一个好办法。

2.安卓端进行补偿绘制，将开始绘制前的数据点也收集起来，等正式需要绘制的时候一并绘制。

我们发现的第二个问题是：enow和安卓画出的线并不一致，因为是这两端的数据采集是相互独立的，并不一致。为什么会这样呢？我的想法是，假设一个理想情况，我们能拿到足够多的点，那么我们应当绘制出一条理想的跟轨迹完全契合的曲线，如果在极端情况下，只有起点和终点，我们画出的就是一个线段，完全偏离真实轨迹，如果在一个中间情况，点部分的丢失，那么确实可能会像我们遇到的这个问题一样，曲线部分偏离。所以我的猜想是：electron端采集到的点没有安卓多导致的曲线偏离。那么该怎么让点尽可能多呢？我们可以利用浏览器提供的另一个事件来代替当前使用的TouchMove, PointerMove. 这里有个简单的测试，来证明PointerMove事件比TouchMove事件的密度大。[贴对比视频] 改完之后经过验证，确实有效。

我稍微介绍一下PointerEvent, 它有几个特点，继承自MouseEvent, 说明MouseEvent有的属性它都有，它还补充了几个特别的属性，压感、倾斜角度、isPrimary属性，另外还有一个实验中的方法：getCoalescedEvents， 作用是将事件点聚合，在低性能设备上浏览器事件的触发响应无法非常灵敏时，非常有用。
