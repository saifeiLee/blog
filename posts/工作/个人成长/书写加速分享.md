# 书写加速

## 提纲

### 1. 方案简介

 enow事件流->electron->Node-Addon->Turn on/off Accelerator

### 遇到的问题

    a: 首笔延迟（视频展示）
    d: 两端线条绘制的一致性

### 3. 问题原因简介

#### 首笔延迟

安卓端启动需要时间，这段时间内的事件点丢失导致首笔绘制的延迟。

#### 两端线条绘制的一致性

[视频展示] 原因分析：点越多，越能绘制出完全契合轨迹的曲线，如果只有两个点（起始点和结束点）画出来的是一个线段，所以可以认为点越少，画出的曲线就会越偏离真实轨迹。
如何拿到更多的点：PointerMove事件

#### PointerEvent简介

- 继承自MouseEvent

#### 为什么二次贝塞尔曲线能够画出圆滑的曲线

数学上对平滑曲线的定义：函数曲线的一阶导数连续=》函数连续的证明：自变量从任何方向接近c, f(c)的极限都存在且等于f(c)

## 草稿

各位中午好，今天的分享主题是书写加速，不包括代码方面的优化，主要介绍一下ElectronUOS平台书写伪加速的实现方案，并对遇到的问题做个总结。

这次的加速方案，其核心是安卓伪加速。整个方案中有几个关键角色：安卓加速应用，职责是在安卓层绘制出书写曲线，然后在收到指令时将其清除。MQTT是我们五代机上已有的一个服务模块，作用是实现双系统之间的通信。最后一个角色是Node模块，负责跟MQTT模块通信，封装好控制安卓加速应用的相关API给应用层使用。我们在Electron层接入Node模块，将接口进行封装，最终通过事件响应的方式，在enow和electron之间建立起联系，实现安卓加速的开启和关闭。这里有个细节，如果各位今后在需要webpack打包的项目里使用node格式的native包，一定要记得添加webpack-node-loader。

还存在一些问题需要解决：

首笔延迟问题，这个问题的原因是安卓应用的启动[start]需要时间，在这段时间内的点被丢掉了。大家不妨思考一下，你会如何解决这个问题？

1. 延迟关闭
2. 安卓端进行补偿绘制，思路是将开始绘制前的数据点也收集起来，等正式需要绘制的时候一并绘制。

我们发现的第二个问题是：enow和安卓画出的线并不一致，因为是这两端的数据采集是相互独立的，并不一致。为什么会这样呢？我的想法是，假设一个理想情况，我们能拿到足够多的点，那么我们应当绘制出一条理想的跟轨迹完全契合的曲线，如果在极端情况下，只有起点和终点，我们画出的就是一个线段，完全偏离真实轨迹，如果在一个中间情况，点部分的丢失，那么确实可能会像我们遇到的这个问题一样，曲线部分偏离。所以我的猜想是：electron端采集到的点没有安卓多导致的曲线偏离。那么该怎么让点尽可能多呢？我们可以利用浏览器提供的另一个事件来代替当前使用的TouchMove, PointerMove. 这里有个简单的测试，来证明PointerMove事件比TouchMove事件的密度大。[贴对比视频] 改完之后经过验证，确实有效。

我稍微介绍一下PointerEvent, 它有几个特点，继承自MouseEvent, 说明MouseEvent有的属性它都有，它还补充了几个特别的属性，压感、倾斜角度、isPrimary属性，另外还有一个实验中的方法：getCoalescedEvents， 作用是将事件点聚合，在低性能设备上浏览器事件的触发响应无法非常灵敏时，非常有用。

以上就是今天我的分享内容，感谢大家参与～
